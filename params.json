{"name":"Sorabji","tagline":"","body":"One of my large projects as an in-house developer for a consulting firm is a managed survey data dashboard. Our consultants prepare data and automated reports for our clients, who access them through our website. We are a small (7 people) office in a niche industry, so I work closely with all of the consultants in improving and updated the administrative portion of the website.\r\n\r\nA big goal of ours was to create a streamlined product that we could process with a standard workflow, even when the underlying data varied considerably. One of the tools I developed fairly early on was a scripting tool that our consultants could use to write macros that perform common or repetitive data transformations. The macros would run automatically when new data was imported from a datafile or API, and the transformations would be essentially self-documenting.\r\n\r\n### The Problem\r\n\r\nIt was Ruby. Not Ruby-like or Ruby-inspired - plain old, eval to a proc on the server Ruby. This is dangerous for numerous obvious reasons, but I was pretty confident that no one in our company would want to maliciously attack the server, and moreover, they wouldn't know how if they did want to.\r\n\r\nHowever, we're starting to license the system to other consulting firms who will act as service providers, so the need to harden this very very soft spot is fairly urgent. Additionally, our consultants have expressed a desire to better understand what the scripts our that I tell them to type in so they can write their own complicated logic, but teaching them the ins and outs of a general purpose programming language is not currently on my list of priorities. They're not developers, but they have a reasonably good understanding of SPSS Syntax and Excel formulae, so I figured I see what I could give them in that vein.\r\n\r\nHaving recently read Tom Stuart's Understanding Computation, I felt I could make a reasonable stab at developing a simple expression language in a short amount of time, the requirements being:\r\n\r\n 1. Single-line expressions only (but nested functions are permitted)\r\n 1. Must compile to a Ruby proc that takes a hash-like object as an argument (in our specific case, a Mongoid document)\r\n 1. Evaluation only (the compiled proc would not be allowed to mutate any data - I am handling this within the Rails app)\r\n 1. Simple enough syntax and a small enough API to learn in 15 - 30 minutes for a non-developer\r\n 1. Can do everything we have already done in the last 12 months using the Ruby macros.\r\n\r\nI used Treetop to write a grammar specification and implemented the language behind it. I'll go into a bit more detail later on, but first, let's briefly look at the syntax:\r\n\r\n**A basic list/array**: `[1 2 3]`. I purposefully decided the value separator should be a single space rather than a comma or some other character, simply because it's one fewer thing for non-programmers to remember.\r\n\r\nHere are some syntax examples along with the Ruby code they replaced.\r\n\r\n**The basic lookup function**: remember, this operates on hash-like objects that implement the square brackets operator (most our data is stored by an id reference to a MySQL table, hence the integer keys).\r\n\r\nOld style: `r[276]`, `r[:external_id]`\r\nNew style: `{276}`, `{external_id}`\r\n\r\nA series of variables can be looked up as a list like this: `{101 102 103 external_id}`\r\n\r\n**A reference object lookup**: In the case of our dashboard, each respondent (or 'case' or 'row' depending on what data analysis world you live in) belongs to a dataset, which can provide some default variables or perform calculations or analyses over the entire cohort.\r\n\r\nOld style, calculating age: `r.survey.date.year - r[276]`\r\nNew style: `{{year}} - {276}`\r\n\r\n**Functions**: there is a very basic set of functions carefully chosen so we could easily re-implement all of our Ruby macros in Sorabji. The syntax is simply a keyword followed by a list (of either `[...]` or `{...}` form).\r\n\r\n**Finding the first present value in a list of possible values, the 'default' function:**\r\n\r\nOld style: `r[101] || r[102] || r[103]`\r\nNew style: `default{101 102 103}`\r\n\r\nYou can mix lookups with integer or other values using the square bracket list:\r\n\r\n`default[{101} 2001]`.\r\n\r\nThis functions similar to Ruby's `hash#fetch` (`{}.fetch(:key, default_value)`).\r\n\r\n**Conditionals are ternary functions**: Another nod to the Excel crowd:\r\n\r\nOld style: `r[101] < 100 ? 1900 + r[270] : r[270]`\r\nNew style: `if[({101} < 100) (1900 + {270}) {270}]`\r\n\r\n**Any sort of reduce or inject function is much simplified over its Ruby equivalent**:\r\n\r\n    [101, 102, 103].inject(0) {|sum, x| sum + r[x].to_i }\r\n    # try explaining why that needs to be so complicated\r\n    sum{101 102 103}\r\n    mean[{101} 10 20]\r\n\r\n## Implementation\r\n\r\nFor the most part, I followed Tom Stuart's example of creating an Abstract Syntax Tree using Ruby structs. Each class would implement a `to_proc` function that determined how it should evaluate the hash being fed into it. Most classes are very simple. Each abstract class was paired with a corresponding `Node` class that inherited from `Treetop::Runtime::SyntaxNode`. I might eventually factor those out, but I found it useful in developing the language to have one set of classes concerned with how the tree is parsed and one concerned with compiling to Ruby procs.\r\n\r\nHere is the Integer Literal class:\r\n\r\n    class IntegerLiteralNode < ASTNode\r\n      def to_ast\r\n        IntegerLiteral.new(text_value.to_i)\r\n      end\r\n    end\r\n\r\n    class IntegerLiteral < Struct.new(:value)\r\n      def to_proc\r\n        ->(*args){ value }\r\n      end\r\n    end\r\n\r\nObviously, the functional representation of an integer value should only ever return the integer value, so the proc is exceedingly simple. The corresponding grammar:\r\n\r\n    rule integer\r\n      [0-9]+ <Sorabji::IntegerLiteralNode>\r\n    end\r\n\r\nYay! I should point out that I have never done this before, and went to school for an entirely unrelated subject, so excuse me while I find it incredibly cool that I can feed in a string like `'9'` to a parser and have it evaluate to a Ruby integer without using the built-in `eval`.\r\n\r\nSimilarly simple primitives like booleans, strings, operators, comparators, etc. have very similar implementations. I'm not going to go through every grammar rule step-by-step here, but the entire specification is available in the repo.\r\n\r\nFast forward a dozen or so commits. I decided that most of my grammar rules fall into one of three categories: entities (anything at all, really), value entities (entities which, when evaluated as a proc, return a single value), and operations.\r\n\r\nValue Entities include:\r\n\r\n  -bracketed expressions\r\n  -reference object lookups (`{{year}}`)\r\n  -object lookups (`{276}`)\r\n  -integers, strings, and booleans\r\n  -functions\r\n\r\nIt took numerous revisions to eventually get to this schema, but once I arrived, I found it was pretty easily extensible. The *really* interesting part turned out to be mathematical operations, which, due to our weird obsession with infix notation, is WAY less intuitive than I expected.\r\n\r\nTo be continued...","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}